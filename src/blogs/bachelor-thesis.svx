---
title: 'Bachelor Thesis'
description: 'Model for Bacteria mixing in three-dimensions using random walker agents'
date: '2023-7-27'
tags:
  - 'thesis'
  - 2023
published: true
author: 'Abel de Bruijn'
---

<script lang="ts">
import Cite from "$lib/components/Cite.svelte";
import * as Label from "$lib/components/label/index.js";
import {AutoRef} from "$lib/components/label/index.js";
import Code from "$lib/components/Code.svelte";
import Equation from "$lib/components/Equation.svelte";
import Image from "$lib/components/Image.svelte";

// Images
import NewMarkerDistributionImage from './assets/bachelor-thesis/Marker Distribution for Thesis.png?enhanced';

// Code
import UpdateUnivereSerialCode from './assets/bachelor-thesis/UpdateUniverseSerialCode.svelte';

</script>

# Territory patterns created by random walker agents in three dimensions

## Abstract

> This research paper proposes a discrete agent-based model to simulate territorial development among micro-organisms. The
> model involves two species that interact through marker signals left behind by agents as they move through a three-dimensional
> lattice. The study builds on previous research that established a phase transition from a well-mixed to a well-segregated state
> for two-dimensional lattices. This research extends the finding to three dimensions and confirms that the properties observed
> in the two-dimensional model are also present in the three-dimensional model. We conclude that the addition of more mass or
> the ratio between gamma and lambda behaves similarly to the two-dimensional model. However, the three-dimensional model
> needs a larger mass to reach the same critical point as the two-dimensional one.

---

<Label.Section title="Introduction" />

Territory formation has been studied in depth in two dimensions (2D) in many other papers.
Some applications include bacteria <Cite paperId="Motility analysis of bacteria-based" />, <Cite paperId="Englert_Manson_Jayaraman_2009" />
or fungi <Cite paperId="Khokon.2021" />. Micro-organisms will often use chemo repellents to establish and maintain their territories,
and to avoid direct competition with other species <Cite paperId="GUILLENGONZALEZ2022193" />. By excreting these chemicals, micro-organisms can create a chemical
boundary that serves as a warning to other organisms to avoid direct contact. This can be especially important in environments where
resources are limited and competition for those resources is high. By avoiding direct competition with other species, organisms can
increase their chances of survival and reproduction. Another notable example of territory formation in two dimensions is the territories
of human gangs, which were researched by A. Alsenafi and A.B. Barbaro <Cite paperId="ALSENAFI2018765" /> (hereafter referred to as the previous territory paper).
In their paper, a model is proposed for gang territory using graffiti. Two gangs will leave behind their own graffiti tags at different
locations that the other gang will attempt to avoid. The paper studies biased random agent movement on a two-dimensional (2D) lattice.
However, the same model can be extended to micro-organisms living in a three-dimensional (3D) lattice. To make the model more applicable
to our case, our paper replaces gangs with species, graffiti with (chemo-repellent) markers, and gang members with agents.

The purpose of this paper is to show how a random walker model behaves in three dimensions with different strengths of avoidance for opposing species.
The main question attempted to be answered is: “What similarities exist between properties of the twodimensional and three-dimensional
lattice models?”. This question is answered with the following sub-questions: "What are the states of the three-dimensional lattice model,
and are they well-mixed or well-segregated?", "How does mass and gamma/lambda ratio influence the phase transition of the 3D model?".

The paper is structured in the following way: First, <AutoRef label="Background and related work" /> shows the background which is needed to understand this paper. <AutoRef label="Method" /> explains how a random walker model is used with pseudo-code. <AutoRef label="A Naive model" /> shows an intuitive algorithm derived from mathematics. <AutoRef label="CPU improvements" /> and <AutoRef label="GPU improvements" /> demonstrate how CPU (Central Processing Unit) and GPU (Graphics Processing Unit) parallel computing can improve the performance of the model. <AutoRef label="Client visualisations" /> explains how the client is interacting and visualising the model. <AutoRef label="Results" /> presents the simulations for multiple configurations. <AutoRef label="Argumentation and discussion" /> discusses what similarities a 3D random walker model creates. <AutoRef label="Conclusion" /> is the conclusion of the paper. Finally, <AutoRef label="Responsible Research" /> discusses the responsibility and accountability of this research paper.

---

<Label.Section title="Background and related work" />

This section is for readers to gain a thorough understanding of the background.

<Label.SubSection title="Taking a drunkard walk" />
Random walk models were first popularised by British mathematician K. Pearson in 1905. He was intrigued by the problem of the random walk and sought assistance from the readers of Nature <Cite paperId="PEARSON_1905" />. The model is built with a lattice in a certain dimension and multiple agents walking the lattice. In each iteration step, all agents chose a random neighbour to walk to.

Back in 1905, when K. Pearson first popularised the random walk model, calculations were mostly done by hand. However, with the invention of better computers, calculations have become much more manageable. However, the random walk is difficult to interpret by humans due to the amount of data generated by the model. This can be a tedious and difficult endeavour.

<Label.SubSection title="Higher-dimensional walks" />
Properties of higher-dimensional random walks were studied by Hungarian mathematician G. Pólya in 1921 <Cite paperId="Polya1921" />. He demonstrated that random walks in higher dimensions possess more intriguing characteristics than those in lower dimensions. For instance, unbiased random walkers tend to end up in the same spot less frequently, when the number of dimensions is increased.

This indicates that higher-dimensional walks are significantly less stable than their lower-dimensional counterparts. It is interesting to find out how stable our model will become in comparison to a 2D model.

<Label.SubSection title="Human gang territories" />
A dual-layered walker model for human gang territories was proposed by A. Alsenafi and A.B. Barbaro. One layer is dedicated to agents walking on a cyclic 2D lattice. The other layer serves to store markers that indicate how popular a given node is for each species.

The number of markers in each lattice node varies over time. At each time step, some markers decay, while agents add their own markers to the node with a certain probability. This is expressed with the following formula:

<Equation label="marker distribution 2d" block latex={String.raw`\xi_i(x,y,t+1) = (1-\lambda)\cdot\xi_i(x,y,t) + \gamma\cdot\rho_i(x,y,t)`} />

For species <Equation latex="i" />, <Equation latex="\xi_i(x,y,t)"/> is the number of markers at position <Equation latex="(x,y)" /> at a time step <Equation latex="t" />, and <Equation latex="\rho_i(x,y,t)"/> is the number of agents of species <Equation latex="i" /> at location <Equation latex="(x,y)" /> at time <Equation latex="t"/> multiplied by the area of the lattice. Global parameter <Equation latex="\lambda"/> controls the rate of marker decay, and <Equation latex="\gamma"/> controls the rate of marker production.

The agents take a biased random walk toward the neighbour with the least amount of markers from the other gang. The probability of an agent from species A moving from location <Equation latex="(x, y)" /> to (&#770;x,&#770;y)
is formulated with the following equation:

<Equation label="agent movement 2D" block latex={String.raw`  M_{A}(x\rightarrow \hat{x} ,y \rightarrow \hat{y}, t) = 
  \frac{e^{-\beta\cdot\xi_{B}(\hat{x},\hat{y},t)}}{\sum\limits_{(\tilde{x},\tilde{y})\sim(x,y)}e^{-\beta\cdot\xi_{B}(\tilde{x},\tilde{y},t))}}`} />

Let <Equation latex="\beta" /> be a global parameter that regulates the strength of avoiding the markers of the other species. Lowering the value of <Equation latex="\beta" /> in this function will decrease the degree of bias towards an agent's preferred neighbour. (&#771;x, &#771;y) is the direct neighbours of <Equation latex="(x,y)" /> or formally written as (&#771;x, &#771;y)<Equation latex="\in (x \pm 1, y),(x, y \pm 1)" />.

To evaluate the state of well-mixed versus well-segregated systems an order parameter is defined:

<Equation label="order parameter 2d" block latex={String.raw`\epsilon = \frac{1}{4L^2N^2} \sum_{(x,y) \in S } \sum_{(\tilde{x},\tilde{y}) \sim(x,y)} (\rho_A(x,y,t) - \rho_B(x,y,t)) (\rho_A(\tilde{x},\tilde{y}, t) - \rho_B(\tilde{x},\tilde{y}, t))`} />

This order parameter is defined such that if neighbouring nodes have the same dominant species, the summand is positive. Conversely, if neighbouring nodes have opposite dominant species, the summand is negative. The coefficient normalises so that the maximum value is capped at 1. For states that are well-mixed, this order parameter produces a value close to 0. In well-segregated states, this value reaches 1.

They concluded that after many iterations, the model began to exhibit segregated states, with a final order parameter greater than 0.01. Furthermore, both the model's mass and gamma to lambda ratio were inversely proportional to the critical beta parameter value.

---

<Label.Section title="Method" />
A general model, independent of dimensions is presented in <AutoRef label="A generalised random walker model" />. A naive example model (later referred to as CPU serial model) is described in <AutoRef label="Naive model" /> with pseudo-code to give the reader an impression of how a 3D territory model is represented in code. In <AutoRef label="CPU improvements" /> a Central processing unit (CPU) algorithm using parallelism is proposed that significantly improves the run-time of the naive model. The model has again improved been in run-time in <AutoRef label="GPU improvements" />, where a dedicated GPU takes some work over. Although the model produces the same output, spotting how the mathematical model is represented in these faster models is harder. This is followed by <AutoRef label="Client visualisations" />, where the method for visualising the model in a browser is presented. Lastly, the method for quantifying territory using an order parameter is presented in <AutoRef label="An order parameter" />.

<Label.SubSection title="A generalised random walker model" />
The model consists of two processes. The first process is initialisation, where a lattice of dimension D and side length L is created. N number of agents are randomly and uniformly distributed across the lattice nodes. The mass per species, also known as <Equation latex="N_i" />, is the same for both species A (red) and B (blue). The second process involves each agent leaving behind markers and moving to a neighbouring node based on the number of markers of the opposing species similar to <AutoRef label="marker distribution 2d" />. Further details about each process are provided in the following paragraphs.

The model is **initialised** with a cyclic lattice, where <Equation latex="D" /> number of dimensions is created. We assume each lattice side to have the same length. This results in a lattice with <Equation latex="L^D" /> nodes with <Equation latex="{'\\lbrace x_1,x_2,...,x_D \\rbrace \\in \\lbrace 0,1,2,...,L-2,L-1  \\rbrace '}" />. Each node is connected to its direct neighbours. Thus, node <Equation latex="(x_1, x_2, ..., x_D)" /> is connected to <Equation latex="{'(\\tilde{x_1},\\tilde{x_2},...,\\tilde{x_D})'}" />, which can be formulated with the following equation:

<Equation label="neighbours general" block latex={String.raw`(\tilde{x_1},\tilde{x_2},...,\tilde{x_D}) \in \{(x_1 \pm 1, x_2, \ldots, x_D), (x_1, x_2 \pm 1, \ldots, x_D), \ldots ,(x_1, x_2, ..., x_D \pm 1) \}`} />
Each node keeps track of its own amount of agents, and the amount of markers.

At each **iteration**, all nodes adjust their amount of markers and agent count. For adjusting markers, <AutoRef label="marker distribution 2d" /> is adapted for <Equation latex="\xi_i"/> and <Equation latex="\rho_i" /> to reference to a location in D-dimensional space. Therefore, our model applies the following equation for adjusting markers between time steps:

<Equation label="marker distribution general" block latex={String.raw`\begin{align}
\xi_i(x_1,x_2,\ldots,x_D,t+1) = (1-\lambda)\cdot\xi_i(x_1,x_2,\ldots,x_D,t) + \\ \gamma\cdot\rho_i(x_1,x_2,\ldots,x_D,t)
\end{align}`} />

Similarly, in <AutoRef label="agent movement 2D" />, the movement of agents is transformed to the following formula:

<Equation label="agent movement 3D" block latex={String.raw`
\begin{align} 
M_{A}(x_1\rightarrow \hat{x_1} , x_2 \rightarrow \hat{x_2}, \ldots, x_D \rightarrow \hat{x_D}, t) = \\ \frac{e^{-\beta\cdot\xi_{B}(\hat{x_1},\hat{x_2},\ldots,\hat{x_D},t)}}{\sum_{(\tilde{x_1},\tilde{x_2}, \ldots,\tilde{x_D})\sim(x_1,x_2,\ldots,x_D)}e^{-\beta\cdot\xi\_{B}(\tilde{x_1},\tilde{x_2},\ldots,\tilde{x_D},t))}}
\end{align}`} />

By utilising these formulae, the adaptability of the model is demonstrated to any number of dimensions, whether it be one, ten, or a thousand. The model's movement in higher dimensions should resemble that of the 2D model proposed in <AutoRef label="Human gang territories" />.

<Label.SubSection title="A naive model" />
We have established that the previous territory paper can be extended to any number of dimensions. To illustrate this, an example is presented with figures and pseudo-codes of how mathematics is used in the 3D model. The example is divided into two sections, similar to the mathematics in <AutoRef label="A generalised random walker model" />.

<Label.SubSubSection title="Initialisation" />

The initialization process is executed every time the model needs to be started or reset. The model is set up with an <Equation latex="L \times L \times L" /> lattice, where each node is connected to its direct neighbours. This connection is described by <AutoRef label="neighbours general" />, with <Equation latex="D = 3" />. All global hyper-parameters (<Equation latex="\beta" />, <Equation latex="\lambda" />, <Equation latex="\gamma" />) are initialised so they can be accessed by the iteration process.

To maintain the separation of concerns, a separate layer is allocated for agents and markers. N agents from both species A and B are randomly (uniformly) distributed over all nodes. Initially, all markers for each species are set to zero.

<Label.SubSubSection title="Iteration" />

The iteration process runs for each forward time step and will update the model as constructed in the initialisation process. In each iteration, a new empty layer is constructed for both agents and markers to write to. The old layers are only used to read from. This is done to prohibit the behaviour that a node from time t is requested to be read. However, the node data is already partially updated with data for time (t + 1).

The iteration process starts by writing to the layer of the new marker using equation <AutoRef label="marker distribution general" />. The data from the old agent and marker layers are read and computed together. The result of the equation is stored in the layer of the new markers as illustrated in <AutoRef label="new marker dist" />.

<Image image={NewMarkerDistributionImage} label="new marker dist">
  This figure shows an example of a lattice with L = 3 and D = 3. The example highlights how the markers are updated at position (0,0,0). A new lattice is created to store the next iteration of markers. The old data from the marker and agent layers are read and combined to write to the new layer.
</Image>

The iteration process continues with each agent randomly selecting one of its neighbours, weighted by the number of markers the neighbours possess. As mentioned before, agents prefer neighbours with lower markers of the opposite species. A pseudo-code implementation for moving the red agents is given in <AutoRef label="update universe serial" />.

Each iteration ends by removing the old lattices and replacing them with the newer ones. If no errors occur, the iteration count increases.

<Code label="update universe serial">
  <UpdateUnivereSerialCode />
</Code>

<!-- \For {$(agent\_node, marker\_node, index) \gets old\_lattices.iter()$}
    \MyComment{Loop over every agent and marker node in the old lattices}

    \State prng $\gets$ new PRNG(index, iteration, seed);
    \MyComment{Setup a pseudorandom number generator (PRNG). The seed should depend on the index and iteration amount, as well as a global seed provided by the user.}

    \State neighbour\_markers = marker\_node.neighbours()
    \MyComment{Get the 6 neighbours of this marker node}
    % \State
    \State blue\_strength = \{\}
    \MyComment{Store push strengths of all neighbours}
    \For {$marker \gets neighbour\_markers.iter()$}
        % \MyComment{Loop over every neighbour marker }
        \State $blue\_strengths \gets pow(e,-beta \times marker.blue\_value)$
        \MyComment{Append the blue strength for each marker defined in equation \ref{eq: agent movement 3D} }
    \EndFor

    \State

    \For{$red\_agent \gets agent\_node.red\_agents$}
        \MyComment{Loop over each red\_agent and move it to one of its neighbours according to the strengths of the blue markers}
        \State direction = \Call{pick\_weighted}{prng, blue\_strengths}
        \MyComment{Pick one of the neighbours and return the chosen direction to move in (Top, Left, Front, etc.). More info about the method in  appendix \ref{app: update universe serial extended}}
        \State new\_index $\gets$ agent\_node.index\_from\_dir(direction)
        \MyComment {Get the neighbours index from the direction}
        \State new\_lattices.agent\_nodes.add\_red\_agent(new\_index)
        \MyComment{Increment the new lattice with agent nodes at the position of new\_index by one}
    \EndFor

\EndFor -->

<!-- \subsection{CPU improvements} -->
<!-- The straightforward nature of the naive model makes it easy to understand and apply using the mathematics provided. However, as will be shown in section \ref{section: Algorithm speed}, its execution speed is slow. Iteration is the most time-consuming part of the process. The model is built only once, but the program may have to iterate thousands or even millions of times. To speed up this process while still producing the same output, this section will introduce a faster method of iteration. -->

<!-- Introducing parallel CPU computing can be a good solution when algorithms are running slowly \cite{Concha_Cabido_Pantrigo_Montemayor_2014}. Ideally, using K threads can speed up your program by a factor of K. However, this comes with a cost of unpredictability when multiple threads write to the same memory address. This can lead to a behaviour known as a 'race condition' \cite{Liu_Wang_Zhou_Wang_2022}. -->

<!-- Race conditions can introduce unpredictable and unstable behaviour. An example can be where an agent is moving from one node to another. When threads A and B read the agent count of node X simultaneously and both try to write one agent to it, only one agent will be added to node X. This results in a loss of total agents which is not allowed in this model. A Mutex \cite{10.1007/978-3-642-21834-7_13} prevents simultaneous access to a piece of memory, though this comes with a performance cost as only one thread can access it at a time. By performing all writing calculations within each node and spawning one thread per node, we ensure that only one thread is writing to a memory address during the node's lifetime. -->

<!-- Only the walking part needs to be updated from the naive model, as updating the markers is not writing to other nodes other than itself, as shown in figure \ref{fig: new marker dist}. Algorithm \ref{alg: update universe serial} is adopted, whereby each node can read all other nodes but can only write to its own. An impression of how the movement of red agents is changed is visible in algorithm \ref{alg: update universe parallel}. -->

<!-- \begin{algorithm}[hbt!]
\caption{Moving red agents with parallisation}\label{alg: update universe parallel}
\begin{algorithmic}
\State new\_lattices = new Lattices(old\_lattices.parameters)
\For {$ (marker\_node, agent\_node, index) \gets old\_lattices $}
    \MyComment{Move agents out by storing the newly distributed agents in this agent node}
    \State neighbour\_markers = marker\_node.neighbours()
    \State prng = new PRNG(index, iteration);

    \State agents\_out = \{top:0,right:0,front:0,bottom:0,left:0,back:0\}
    \For{$red\_agent \gets agent\_node.red\_agents.iter()$}
        \State blue\_strengths = neighbour\_markers.blue\_strengths
        \MyComment{Set of blue strength for each neighbouring node}
        \State dir = pick\_weighted(prng, blue\_strengths)
        \State agents\_out[dir] += 1
    \EndFor

    \State new\_lattices.agent\_nodes[index].red\_agents\_out(agents\_out)
    \MyComment{Write the number of agents that will go to each neighbour to own (index) of the new agent node}
\EndFor
\State
\For {$ (agent\_node, index) \gets new\_lattices $}
    \MyComment{Read agents from neighbouring nodes and move to this node. For instance, get top neighbours agents that should move down (i.e. to this node).}
    \State neighbour\_agents = agent\_node.neighbours()

    \State total\_red\_agents = 0
    \For {dir $\gets$ neighbour\_agents}
        \State red\_agents\_dir $\gets$ neighbour\_agents[dir].red\_agents\_out
        \MyComment{Set of all agents in the neighbour at dir (top, right, etc)}
        \State total\_red\_agents += red\_agents\_dir[dir.opposite]
        \MyComment{Add red agents from dir.opposite (top -> bottom, right -> left)}
    \EndFor

    agent\_node.red\_agents(total\_red\_agents)
    \MyComment{Set red agents that this node gets from all neighbours}
\EndFor
\end{algorithmic}
\end{algorithm} -->

<!-- \subsection{GPU improvements} -->

<!-- The speed of the parallelised CPU implementation was still insufficient, as will be discussed in section \ref{section: Algorithm speed}. Most GPUs have many more working threads compared to CPUs, this means that GPUs are able to do parallel computations. The GPU implementation was written using WebGPU \cite{Maxfield:23:W} as the core technology. This web API provides direct access to most GPUs on desktop computers, making the model versatile and more easily reproducible.  -->

<!-- WebGPU is often described as a successor of WebGL. WebGL was mostly used for drawing images on the browser screen, whereas WebGPU was designed from the ground up to handle complex GPU computations. WebGPU uses its own shader-language WGSL to reach near-native performance. -->

<!-- GPUs have one downside: data transfers between the CPU and GPU take a relatively significant amount of time. The algorithm is designed to use a ping-pong buffer to store the old and new lattices in GPU memory, reducing the time needed to transfer data to the CPU. A ping-pong buffer consists of two buffers that are used in an alternating fashion. One buffer is used for input, while the other is used for output. Each iteration they swap their function as input or output buffer. This technique reduces latency and enhances performance in real-time applications. -->

<!-- \subsection{Visualisations} -->
<!-- To interpret the raw data model, several visualisation methods have been developed. These fall into three categories: 2D slice, 3D View and Real-time data view. These categories can be seen in figure \ref{fig: views}. To study these views in detail, visit \URL{https://3d-walker.vercel.app/vision/slice} for a live view. The purpose for each category is explained further in the respective paragraphs. -->

<!-- The left figure is the \textbf{slice view} and is useful for comparing the current 3D state to the 2D one. If patterns similar to those expected from the 2D case start emerging from a given configuration, it often indicates that we are moving towards an interesting state to compare against. However, each slice is in general an invalid 2D state because agents can cluster and move to slices in the front and back. The assumption of an equal number of agents from species A and B is often not true, so direct comparisons should be made with caution. -->

<!-- \begin{figure}[htb]
  \centering
  \includegraphics[width=1\linewidth]{images/views.png}
  \caption{\label{fig: views} Left: 2D slicing view. Centre: 3D view and right: data view. All three views display the visuals for lattice area $50^3$, iterations 31001, beta = 1.5e-5, $\gamma$ = 0.5, $\lambda$ = 0.5. }
\end{figure} -->

<!-- The centre figure shows the \textbf{3D view}. Drawing each node as a coloured block is difficult to interpret in 3D, because blocks that are hidden by others are hard to spot. The marching cubes algorithm \cite{MarchingCubes} is often used in the three-dimensional visualisation of territories. This technique shows the border at which species are equally dominant. Blue-shaded areas describe territories, where the blue species is most dominant. Observe how the slicing view at index z=0 is recognised at the front (left) side of the cube. -->

<!-- Lastly, the right figure is \textbf{real-time data view}. This is for abstracting the visuals away and showing condensed metrics about the model. Here, the order parameter over time which will be defined in section \ref{section: An order parameter} is shown. Hovering over each data point reveals the exact order parameter at each time step. -->

<!-- \subsection{3D order parameter}
\label{section: An order parameter}
The previous territorial paper employed an order parameter to measure the effect of various parameters on the state of well-mixed versus segregated systems. The order parameter (as defined in equation \ref{eq: order parameter 2d}) is adapted to use agent densities in three dimensions, where the agent density of species i is formulated as $\rho_i(x,y,z,t) =$ (amount of agents  at position (x,y,z) and time t) * $L^3$.
\begin{multline}
\label{eq: order param 3d}
\epsilon = \frac{1}{6L^3N^2} \sum_{(x,y,z) \in S } \sum_{(\tilde{x},\tilde{y},\tilde{z}) \sim(x,y,z)} \\(\rho_A(x,y,z,t) - \rho_B(x,y,z,t)) (\rho_A(\tilde{x},\tilde{y},\tilde{z} t) - \rho_B(\tilde{x},\tilde{y},\tilde{z} t))
\end{multline}
The normalisation coefficient is adapted too. We divide the entire equation by the product of the number of neighbours, lattice area, and total mass squared. This keeps the order parameter bounded at 1, making comparisons between papers easier. -->
